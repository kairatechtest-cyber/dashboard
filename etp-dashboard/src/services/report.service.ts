

import { Injectable, inject } from '@angular/core';
import { AuthService } from './auth.service';
import { ActivityLogService } from './activity-log.service';
import { DashboardDataService, HistoricalParameterData } from './dashboard-data.service';

// Declare jspdf and its autoTable plugin to avoid TypeScript errors,
// as they are loaded from a CDN script in index.html.
declare var jspdf: any;

interface TrendAnalysis {
  overallAverage: number;
  overallMin: number;
  overallMax: number;
  trend: 'Increasing' | 'Decreasing' | 'Stable';
  percentageChange: number;
  percentageChangeDisplay: string;
}

@Injectable({
  providedIn: 'root',
})
export class ReportService {
  private authService = inject(AuthService);
  private activityLogService = inject(ActivityLogService);
  private dataService = inject(DashboardDataService);

  private _addHeaderAndFooter(doc: any, title: string, subtitle: string): void {
    const pageCount = doc.internal.getNumberOfPages();
    const user = this.authService.currentUser();
    
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);

        // Header
        doc.setFontSize(20);
        doc.setFont('helvetica', 'bold');
        doc.text('wipro: water - ETP Report', 14, 22);
        
        doc.setLineWidth(0.5);
        doc.line(14, 26, 196, 26);

        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text(title, 14, 36);

        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(100);
        doc.text(subtitle, 14, 42);

        if(user) {
            doc.text(`Generated by: ${user.name} (${user.email})`, 196, 36, { align: 'right' });
        }
        doc.text(`Generated on: ${new Date().toLocaleString()}`, 196, 42, { align: 'right' });


        // Footer
        doc.setFontSize(9);
        doc.setTextColor(150);
        doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 25, doc.internal.pageSize.height - 10);
        doc.text('ETP CloudVision Report', 14, doc.internal.pageSize.height - 10);
    }
  }

  private _calculateTrendAnalysis(data: HistoricalParameterData | undefined): TrendAnalysis | null {
    if (!data || data.tableData.length === 0) return null;
    const dailyAverages = data.tableData.map(d => d.avg);
    const overallAverage = dailyAverages.reduce((s, v) => s + v, 0) / dailyAverages.length;
    const overallMin = Math.min(...data.tableData.map(d => d.min));
    const overallMax = Math.max(...data.tableData.map(d => d.max));
    let trend: 'Increasing' | 'Decreasing' | 'Stable' = 'Stable';
    let percentageChange = 0;

    if (data.chartData.length >= 2) {
      const startValue = data.chartData[0].value;
      const endValue = data.chartData[data.chartData.length - 1].value;
      percentageChange = startValue !== 0 ? ((endValue - startValue) / Math.abs(startValue)) * 100 : (endValue > 0 ? 9999 : 0);
      if (percentageChange > 5) trend = 'Increasing';
      else if (percentageChange < -5) trend = 'Decreasing';
    }

    const percentageChangeDisplay = Math.abs(percentageChange) > 1000 ? `(>${percentageChange > 0 ? '' : '-'}999%)` : `(${(percentageChange >= 0 ? '+' : '')}${percentageChange.toFixed(1)}%)`;
    
    return { overallAverage, overallMin, overallMax, trend, percentageChange, percentageChangeDisplay };
  }
  
  async generateRealtimeRangePdfReport(startDateStr: string, endDateStr: string): Promise<{ doc: any; dataUrl: string }> {
      const data = await this.dataService.getHistoricalData(startDateStr, endDateStr);
      const doc = new jspdf.jsPDF();
      let lastY = 55;
      const tableConfig = {
        theme: 'grid',
        headStyles: { fillColor: [16, 185, 129] }, // emerald-500
      };

      // --- Daily Summaries Section ---
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Daily Parameter Summaries', 14, lastY);
      lastY += 8;

      const addSummaryTable = (title: string, tableData: any[]) => {
          if (lastY > 250) { // Check if we need a new page
              doc.addPage();
              lastY = 55;
          }
          (doc as any).autoTable({
            ...tableConfig,
            head: [[title, 'Avg', 'Min', 'Max']],
            body: tableData.map(d => [d.date, d.avg, d.min, d.max]),
            startY: lastY,
            didDrawPage: (hookData: any) => { lastY = hookData.cursor.y; }
          });
          lastY = (doc as any).autoTable.previous.finalY + 10;
      };

      addSummaryTable('Inflow Flow', data.inflow.flow.tableData);
      addSummaryTable('Inflow TDS', data.inflow.tds.tableData);
      addSummaryTable('Inflow pH', data.inflow.ph.tableData);
      addSummaryTable('Effluent Flow', data.effluent.flow.tableData);
      addSummaryTable('Effluent TDS', data.effluent.tds.tableData);
      addSummaryTable('Effluent pH', data.effluent.ph.tableData);

      const formattedStart = new Date(startDateStr).toLocaleString();
      const formattedEnd = new Date(endDateStr).toLocaleString();
      this._addHeaderAndFooter(doc, 'Operational Log Report', `Report for period: ${formattedStart} to ${formattedEnd}`);
      
      const user = this.authService.currentUser();
      if (user) {
        this.activityLogService.logActivity(user.email, 'Generated Operational Log PDF report');
      }

      return { doc, dataUrl: doc.output('datauristring') };
  }

  async generateHistoricalPdfReport(startDateStr: string, endDateStr: string): Promise<{ doc: any; dataUrl: string }> {
      const data = await this.dataService.getHistoricalData(startDateStr, endDateStr);
      const doc = new jspdf.jsPDF();
      let lastY = 55;
      const tableConfig = {
        theme: 'grid',
        headStyles: { fillColor: [16, 185, 129] }, // emerald-500
      };

      // --- Analysis Section ---
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Trend Analysis Summary', 14, lastY);
      lastY += 8;

      const analyses = {
        inflowFlow: this._calculateTrendAnalysis(data.inflow.flow),
        inflowTds: this._calculateTrendAnalysis(data.inflow.tds),
        inflowPh: this._calculateTrendAnalysis(data.inflow.ph),
        effluentFlow: this._calculateTrendAnalysis(data.effluent.flow),
        effluentTds: this._calculateTrendAnalysis(data.effluent.tds),
        effluentPh: this._calculateTrendAnalysis(data.effluent.ph),
      };

      (doc as any).autoTable({
        ...tableConfig,
        head: [['Parameter', 'Avg', 'Min', 'Max', 'Trend', '% Change']],
        body: Object.entries(analyses).map(([key, analysis]) => {
          const name = key
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .replace('inflow', 'Inflow')
            .replace('effluent', 'Effluent');
            
          return analysis ? [
            name,
            analysis.overallAverage.toFixed(2),
            analysis.overallMin.toFixed(2),
            analysis.overallMax.toFixed(2),
            analysis.trend,
            analysis.percentageChange.toFixed(2) + '%'
          ] : [name, 'N/A', 'N/A', 'N/A', 'N/A', 'N/A'];
        }),
        startY: lastY,
        didDrawPage: (hookData: any) => { lastY = hookData.cursor.y; }
      });
      lastY = (doc as any).autoTable.previous.finalY + 15;

      // --- Daily Summaries ---
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Daily Summaries', 14, lastY);
      lastY += 8;

      const addSummaryTable = (title: string, tableData: any[]) => {
          if (lastY > 250) { // Check if we need a new page
              doc.addPage();
              lastY = 55;
          }
          (doc as any).autoTable({
            ...tableConfig,
            head: [[title, 'Avg', 'Min', 'Max']],
            body: tableData.map(d => [d.date, d.avg, d.min, d.max]),
            startY: lastY,
            didDrawPage: (hookData: any) => { lastY = hookData.cursor.y; }
          });
          lastY = (doc as any).autoTable.previous.finalY + 10;
      };

      addSummaryTable('Inflow Flow', data.inflow.flow.tableData);
      addSummaryTable('Inflow TDS', data.inflow.tds.tableData);
      
      const formattedStart = new Date(startDateStr).toLocaleString();
      const formattedEnd = new Date(endDateStr).toLocaleString();
      this._addHeaderAndFooter(doc, 'Historical Analysis Report', `Report for period: ${formattedStart} to ${formattedEnd}`);
      
      const user = this.authService.currentUser();
      if (user) {
        this.activityLogService.logActivity(
          user.email,
          `Generated Historical PDF report for period: ${startDateStr} to ${endDateStr}`
        );
      }

      return { doc, dataUrl: doc.output('datauristring') };
  }
  
  async emailReport(recipient: string, message: string, pdfDataUrl: string): Promise<boolean> {
    const user = this.authService.currentUser();
    if (!user) {
        console.error('Cannot email report without a logged-in user.');
        return false;
    }

    console.log('--- MOCK EMAIL SERVICE ---');
    console.log(`Sending report to: ${recipient}`);
    console.log(`Message: ${message || '(No message provided)'}`);
    console.log(`Attachment size (base64): ${pdfDataUrl.length} characters`);
    console.log('--------------------------');

    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 1500));

    // Log the activity
    this.activityLogService.logActivity(user.email, `Emailed report to ${recipient}`);
    
    // In a real app, this would return true/false based on the API response.
    return true; 
  }
}
